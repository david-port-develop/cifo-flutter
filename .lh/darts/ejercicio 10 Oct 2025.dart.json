{
    "sourceFile": "darts/ejercicio 10 Oct 2025.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1760270646595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760273556501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,13 @@\n import 'dart:io';\n+import 'dart:math';\n import 'funciones_comunes.dart';\n \n // =============================================\n // BLOQUE 1: Funciones básicas y con retorno\n // =============================================\n \n-// 1. Función Hola mundo\n+// 1. Función sin parámetros ni retorno\n void holaMundo() {\n   print('Hola, mundo');\n }\n // Lógica: Función void simple que ejecuta un print básico\n@@ -21,19 +22,18 @@\n int sumar(int a, int b) {\n   return a + b;\n }\n \n-//también podría ser\n-sumarflecha(int a, int b) => a + b;\n // Lógica: Operación aritmética básica con retorno de resultado\n+//Todas las funciones que solo tienen un return se puede usar la notación de flecha, por ejemplo:\n+sumarflechas(int a , int b) => a + b;\n \n // 4. Función que calcula promedio de tres notas\n double calcularPromedio(double a, double b, double c) {\n   return (a + b + c) / 3;\n }\n+// Lógica: Cálculo de media aritmética con división por cantidad\n \n-// Lógica: Cálculo de media aritmética con división por cantidad\n-// también podría hacerse con flecha como las siguientes\n // 5. Función que verifica si un número es par\n bool esPar(int numero) {\n   return numero % 2 == 0;\n }\n@@ -81,123 +81,201 @@\n }\n // Lógica: Transformación de string a mayúsculas usando método nativo\n \n // =============================================\n-// BLOQUE 2: Tipos de argumentos\n+// BLOQUE 2: Tipos de argumentos (TODAS VALIDADAS)\n // =============================================\n \n-// 11. Función con parámetro opcional\n-void saludarOpcional([String nombre = \"invitado\"]) {\n-  print('Hola, $nombre!');\n+// 1. Función con parámetro opcional - MEJORADA\n+void saludarOpcional([String? nombre]) {\n+  if (nombre == null || nombre.isEmpty) {\n+    print('Hola, invitado!');\n+  } else {\n+    print('Hola, $nombre!');\n+  }\n }\n-// Lógica: Parámetro opcional con valor por defecto para flexibilidad\n+// Lógica: Validación de null y string vacío para parámetro opcional\n \n-// 12. Función con parámetros nombrados\n+// 2. Función con parámetros nombrados - MEJORADA\n void mostrarDatos({required String nombre, required int edad}) {\n+  // Validar datos antes de usarlos\n+  if (nombre.isEmpty) {\n+    print('Error: El nombre no puede estar vacío');\n+    return;\n+  }\n+  if (edad < 0 || edad > 150) {\n+    print('Error: La edad debe estar entre 0 y 150 años');\n+    return;\n+  }\n   print('Nombre: $nombre, Edad: $edad');\n }\n-// Lógica: Parámetros nombrados para llamadas más legibles y explícitas\n+// Lógica: Validación de rangos y valores vacíos en parámetros required\n \n-// 13. Función con validación de parámetro opcional\n+// 3. Función con validación de parámetro opcional - CORRECTA\n void mensajeError([String? mensaje]) {\n-  if (mensaje == null) {\n-    print('Error: No se proporcionó mensaje');\n+  if (mensaje == null || mensaje.isEmpty) {\n+    print('Error: No se proporcionó mensaje válido');\n   } else {\n     print('Mensaje: $mensaje');\n   }\n }\n-// Lógica: Validación de null para parámetros opcionales no proporcionados\n+// Lógica: Validación de null y string vacío\n \n-// 14. Función con parámetro con valor por defecto\n-void mostrarInfo(String nombre, int edad, [String pais = \"España\"]) {\n-  print('$nombre, $edad años, de $pais');\n+// 4. Función con parámetro con valor por defecto - MEJORADA\n+void mostrarInfo(String nombre, int edad, [String? pais]) {\n+  // Validar parámetros obligatorios\n+  if (nombre.isEmpty) {\n+    print('Error: El nombre es obligatorio');\n+    return;\n+  }\n+  if (edad <= 0) {\n+    print('Error: La edad debe ser positiva');\n+    return;\n+  }\n+  \n+  // Usar valor por defecto si no se proporciona país\n+  String paisMostrar = pais ?? \"España\";\n+  print('$nombre, $edad años, de $paisMostrar');\n }\n-// Lógica: Parámetro posicional opcional con valor predeterminado\n+// Lógica: Validación de parámetros obligatorios y manejo de opcionales\n \n-// 15. Función que verifica si lista contiene número\n-bool contieneNumero(List<int> lista, int numero) {\n+// 5. Función que verifica si lista contiene número - MEJORADA\n+bool contieneNumero(List<int>? lista, int numero) {\n+  if (lista == null || lista.isEmpty) {\n+    print('Error: La lista está vacía o es nula');\n+    return false;\n+  }\n   return lista.contains(numero);\n }\n-// Lógica: Uso de método contains para búsqueda en colección\n+// Lógica: Validación de lista nula o vacía\n \n-// 16. Función que repite texto\n-void repetirTexto(String texto, [int repeticiones = 1]) {\n-  for (int i = 0; i < repeticiones; i++) {\n+// 6. Función que repite texto - MEJORADA\n+void repetirTexto(String texto, [int? repeticiones]) {\n+  // Validar texto\n+  if (texto.isEmpty) {\n+    print('Error: El texto no puede estar vacío');\n+    return;\n+  }\n+  \n+  // Usar valor por defecto si no se proporciona\n+  int repeticionesValidas = repeticiones ?? 1;\n+  \n+  // Validar repeticiones\n+  if (repeticionesValidas <= 0) {\n+    print('Error: Las repeticiones deben ser mayor a 0');\n+    return;\n+  }\n+  \n+  for (int i = 0; i < repeticionesValidas; i++) {\n     print(texto);\n   }\n }\n-// Lógica: Bucle controlado por parámetro opcional para repeticiones\n+// Lógica: Validación completa de todos los parámetros\n \n-// 17. Función con múltiples parámetros opcionales\n-double mediaOpcional(int a, [int? b, int? c]) {\n-  int suma = a;\n-  int contador = 1;\n-\n-  if (b != null) {\n-    suma += b;\n-    contador++;\n+// 7. Función con múltiples parámetros opcionales - MEJORADA\n+double? mediaOpcional([int? a, int? b, int? c]) {\n+  List<int> numeros = [];\n+  \n+  // Solo agregar números no nulos\n+  if (a != null) numeros.add(a);\n+  if (b != null) numeros.add(b);\n+  if (c != null) numeros.add(c);\n+  \n+  // Validar que tenemos al menos un número\n+  if (numeros.isEmpty) {\n+    print('Error: Se requiere al menos un número para calcular la media');\n+    return null;\n   }\n-  if (c != null) {\n-    suma += c;\n-    contador++;\n+  \n+  // Calcular suma\n+  int suma = 0;\n+  for (int numero in numeros) {\n+    suma += numero;\n   }\n-\n-  return suma / contador;\n+  \n+  return suma / numeros.length;\n }\n-// Lógica: Suma condicional de parámetros opcionales no nulos\n+// Lógica: Validación de que al menos un parámetro no sea null\n \n-// 18. Función que accede a elemento de lista con control de rango\n-dynamic obtenerElemento(List lista, int indice) {\n-  if (indice >= 0 && indice < lista.length) {\n-    return lista[indice];\n-  } else {\n-    return 'Índice fuera de rango';\n+// 8. Función que accede a elemento de lista con control de rango - CORRECTA\n+dynamic obtenerElemento(List? lista, int indice) {\n+  if (lista == null || lista.isEmpty) {\n+    return 'Error: La lista está vacía o es nula';\n   }\n+  if (indice < 0 || indice >= lista.length) {\n+    return 'Error: Índice $indice fuera de rango (0-${lista.length - 1})';\n+  }\n+  return lista[indice];\n }\n-// Lógica: Validación de límites antes de acceso a elemento de lista\n+// Lógica: Validación de lista nula/vacía y rango de índice\n \n-// 19. Función con múltiples parámetros nombrados\n-String crearPerfil(\n-    {required String nombre, required int edad, bool activo = true}) {\n-  String estado = activo ? 'activo' : 'inactivo';\n+// 9. Función con múltiples parámetros nombrados - MEJORADA\n+String crearPerfil({String? nombre, int? edad, bool? activo}) {\n+  // Validar parámetros requeridos\n+  if (nombre == null || nombre.isEmpty) {\n+    return 'Error: El nombre es obligatorio';\n+  }\n+  if (edad == null || edad < 0 || edad > 150) {\n+    return 'Error: La edad debe estar entre 0 y 150 años';\n+  }\n+  \n+  // Valor por defecto para activo\n+  bool estadoActivo = activo ?? true;\n+  String estado = estadoActivo ? 'activo' : 'inactivo';\n+  \n   return '$nombre, $edad años - $estado';\n }\n-// Lógica: Interpolación con parámetros nombrados y valor por defecto\n+// Lógica: Validación completa de parámetros nombrados\n \n-// 20. Función que combina parámetros posicionales y nombrados\n-void mostrarCombinado(String nombre,\n-    {int edad = 0, String ciudad = \"Desconocida\"}) {\n-  print('$nombre, $edad años, de $ciudad');\n+// 10. Función que combina parámetros posicionales y nombrados - MEJORADA\n+void mostrarCombinado(String nombre, {int? edad, String? ciudad}) {\n+  // Validar parámetro obligatorio\n+  if (nombre.isEmpty) {\n+    print('Error: El nombre es obligatorio');\n+    return;\n+  }\n+  \n+  // Valores por defecto para parámetros nombrados\n+  int edadMostrar = edad ?? 0;\n+  String ciudadMostrar = ciudad ?? \"Desconocida\";\n+  \n+  // Validar rangos\n+  if (edadMostrar < 0) {\n+    print('Error: La edad no puede ser negativa');\n+    return;\n+  }\n+  \n+  print('$nombre, $edadMostrar años, de $ciudadMostrar');\n }\n-// Lógica: Mix de parámetros posicionales obligatorios y nombrados opcionales\n+// Lógica: Validación de parámetro obligatorio y manejo de opcionales\n \n // =============================================\n // BLOQUE 3: Funciones async, await y Future\n // =============================================\n \n-// 21. Función async que devuelve mensaje después de delay\n+// 1. Función async que devuelve mensaje después de delay\n Future<String> mensajeConRetraso() async {\n   await Future.delayed(Duration(seconds: 2));\n   return \"Mensaje listo después de 2 segundos\";\n }\n // Lógica: Espera asíncrona con delayed antes de retornar resultado\n \n-// 22. Función async que simula descarga\n+// 2. Función async que simula descarga\n Future<void> simularDescarga() async {\n   print('Iniciando descarga...');\n   await Future.delayed(Duration(seconds: 3));\n   print('Descarga completada');\n }\n // Lógica: Simulación de proceso largo con await para pausa controlada\n \n-// 23. Función async que calcula cuadrado con retraso\n+// 3. Función async que calcula cuadrado con retraso\n Future<int> cuadradoConRetraso(int numero) async {\n   await Future.delayed(Duration(seconds: 1));\n   return numero * numero;\n }\n // Lógica: Cálculo sencillo precedido por espera asíncrona\n \n-// 24. Función que combina sync y async\n+// 4. Función que combina sync y async\n Future<int> procesarNumero(int numero) async {\n   // Función sincrónica auxiliar\n   int duplicar(int n) => n * 2;\n \n@@ -206,9 +284,9 @@\n   return resultado;\n }\n // Lógica: Integración de lógica síncrona dentro de flujo asíncrono\n \n-// 25. Función async que procesa lista con pausas\n+// 5. Función async que procesa lista con pausas\n Future<void> procesarLista(List<String> elementos) async {\n   for (String elemento in elementos) {\n     print('Procesando: $elemento');\n     await Future.delayed(Duration(seconds: 1));\n@@ -216,9 +294,9 @@\n   print('Procesamiento completado');\n }\n // Lógica: Iteración con pausas asíncronas entre cada elemento\n \n-// 26. Función que espera múltiples Futures\n+// 6. Función que espera múltiples Futures\n Future<String> combinarFutures() async {\n   String dato1 = await _obtenerDato1();\n   String dato2 = await _obtenerDato2();\n   String dato3 = await _obtenerDato3();\n@@ -241,16 +319,16 @@\n   return 'Dato3';\n }\n // Lógica: Ejecución secuencial de múltiples operaciones asíncronas\n \n-// 27. Función async que calcula área de círculo\n+// 7. Función async que calcula área de círculo\n Future<double> areaCirculoConRetraso(double radio) async {\n   await Future.delayed(Duration(seconds: 2));\n   return 3.1416 * radio * radio;\n }\n // Lógica: Cálculo matemático con simulación de procesamiento largo\n \n-// 28. Función async que simula validación de login\n+// 8. Función async que simula validación de login\n Future<String> validarLogin(String usuario, String contrasena) async {\n   await Future.delayed(Duration(seconds: 2));\n \n   if (usuario == 'admin' && contrasena == '1234') {\n@@ -260,9 +338,9 @@\n   }\n }\n // Lógica: Validación condicional después de simulación de delay\n \n-// 29. Función con bucle y llamadas async\n+// 9. Función con bucle y llamadas async\n Future<void> procesoPorPasos(List<String> pasos) async {\n   for (int i = 0; i < pasos.length; i++) {\n     print('Paso ${i + 1}: ${pasos[i]}');\n     await _simularPaso();\n@@ -274,9 +352,9 @@\n   await Future.delayed(Duration(seconds: 1));\n }\n // Lógica: Control secuencial de pasos con esperas asíncronas\n \n-// 30. Función main async que coordina tareas\n+// 10. Función main async que coordina tareas\n Future<void> main() async {\n   print('=== INICIANDO PROGRAMA PRINCIPAL ===');\n \n   await ejecutarEjerciciosAsync();\n@@ -287,9 +365,9 @@\n // =============================================\n // BLOQUE 4: Manejo de errores con try y catch\n // =============================================\n \n-// 31. División con manejo de errores\n+// 1. División con manejo de errores\n void dividirConManejo(int a, int b) {\n   try {\n     double resultado = a / b;\n     print('Resultado: $resultado');\n@@ -298,9 +376,9 @@\n   }\n }\n // Lógica: Captura de excepción por división entre cero\n \n-// 32. Función con retorno seguro de cociente\n+// 2. Función con retorno seguro de cociente\n double? cocienteSeguro(int a, int b) {\n   try {\n     return a / b;\n   } catch (e) {\n@@ -308,9 +386,9 @@\n   }\n }\n // Lógica: Retorno condicional null en caso de error\n \n-// 33. Conversión de texto a número con manejo de errores\n+// 3. Conversión de texto a número con manejo de errores\n int? convertirTextoANumero(String texto) {\n   try {\n     return int.parse(texto);\n   } catch (e) {\n@@ -319,9 +397,9 @@\n   }\n }\n // Lógica: Validación de formato numérico con parse protegido\n \n-// 34. Lectura segura de número desde teclado\n+// 4. Lectura segura de número desde teclado\n int? leerNumeroSeguro(String mensaje) {\n   print(mensaje);\n   try {\n     String? input = stdin.readLineSync();\n@@ -332,9 +410,9 @@\n   }\n }\n // Lógica: Captura de errores en entrada de usuario con parse\n \n-// 35. Acceso seguro a elemento de lista\n+// 5. Acceso seguro a elemento de lista\n dynamic accesoListaSeguro(List lista, int indice) {\n   try {\n     return lista[indice];\n   } catch (e) {\n@@ -342,9 +420,9 @@\n   }\n }\n // Lógica: Protección contra acceso fuera de límites de lista\n \n-// 36. Simulación de apertura de archivo con error\n+// 6. Simulación de apertura de archivo con error\n void simularAbrirArchivo(String nombreArchivo) {\n   try {\n     if (!nombreArchivo.endsWith('.txt')) {\n       throw Exception('Archivo no encontrado: $nombreArchivo');\n@@ -355,9 +433,9 @@\n   }\n }\n // Lógica: Lanzamiento y captura de excepción personalizada\n \n-// 37. Cálculo de raíz cuadrada con validación\n+// 7. Cálculo de raíz cuadrada con validación\n double? raizCuadradaSegura(double numero) {\n   try {\n     if (numero < 0) {\n       throw Exception('No se puede calcular raíz de número negativo');\n@@ -369,9 +447,9 @@\n   }\n }\n // Lógica: Validación previa y lanzamiento de excepción controlada\n \n-// 38. Función async con manejo de error en Future\n+// 8. Función async con manejo de error en Future\n Future<void> futureConError() async {\n   try {\n     await Future.delayed(Duration(seconds: 1));\n     throw Exception('Error simulado en Future');\n@@ -380,9 +458,9 @@\n   }\n }\n // Lógica: Captura de excepciones en operaciones asíncronas\n \n-// 39. Manejo de diferentes tipos de excepciones\n+// 9. Manejo de diferentes tipos de excepciones\n void manejoMultipleErrores(String texto, int indice) {\n   try {\n     int numero = int.parse(texto);\n     List<int> lista = [1, 2, 3];\n@@ -397,9 +475,9 @@\n   }\n }\n // Lógica: Captura específica por tipo de excepción\n \n-// 40. Análisis detallado de errores\n+// 10. Análisis detallado de errores\n void analizarError(dynamic operacionPeligrosa) {\n   try {\n     operacionPeligrosa();\n   } catch (e) {\n"
                },
                {
                    "date": 1760273976725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,22 +81,22 @@\n }\n // Lógica: Transformación de string a mayúsculas usando método nativo\n \n // =============================================\n-// BLOQUE 2: Tipos de argumentos (TODAS VALIDADAS)\n+// BLOQUE 2: Tipos de argumentos\n // =============================================\n \n-// 1. Función con parámetro opcional - MEJORADA\n+// 1. Función con parámetro opcional\n void saludarOpcional([String? nombre]) {\n   if (nombre == null || nombre.isEmpty) {\n-    print('Hola, invitado!');\n+    print('Hola desconocido!');\n   } else {\n-    print('Hola, $nombre!');\n+    print('Hola $nombre!');\n   }\n }\n // Lógica: Validación de null y string vacío para parámetro opcional\n \n-// 2. Función con parámetros nombrados - MEJORADA\n+// 2. Función con parámetros nombrados\n void mostrarDatos({required String nombre, required int edad}) {\n   // Validar datos antes de usarlos\n   if (nombre.isEmpty) {\n     print('Error: El nombre no puede estar vacío');\n"
                }
            ],
            "date": 1760270646595,
            "name": "Commit-0",
            "content": "import 'dart:io';\nimport 'funciones_comunes.dart';\n\n// =============================================\n// BLOQUE 1: Funciones básicas y con retorno\n// =============================================\n\n// 1. Función Hola mundo\nvoid holaMundo() {\n  print('Hola, mundo');\n}\n// Lógica: Función void simple que ejecuta un print básico\n\n// 2. Función con parámetro para saludo personalizado\nvoid saludarPersonalizado(String nombre) {\n  print('Hola, $nombre! Bienvenido/a');\n}\n// Lógica: Concatenación de string con parámetro para personalización\n\n// 3. Función que retorna suma de dos números\nint sumar(int a, int b) {\n  return a + b;\n}\n//también podría ser\nsumarflecha(int a, int b) => a + b;\n// Lógica: Operación aritmética básica con retorno de resultado\n\n// 4. Función que calcula promedio de tres notas\ndouble calcularPromedio(double a, double b, double c) {\n  return (a + b + c) / 3;\n}\n// Lógica: Cálculo de media aritmética con división por cantidad\n// también podría hacerse con flecha como las siguientes\n// 5. Función que verifica si un número es par\nbool esPar(int numero) {\n  return numero % 2 == 0;\n}\n// Lógica: Uso de módulo para determinar paridad con retorno booleano\n\n// 6. Función que cuenta caracteres de un texto\nint contarCaracteres(String texto) {\n  return texto.length;\n}\n// Lógica: Acceso a propiedad length para obtener tamaño del string\n\n// 7. Función que calcula factorial\nint factorial(int n) {\n  int resultado = 1;\n  for (int i = 1; i <= n; i++) {\n    resultado *= i;\n  }\n  return resultado;\n}\n// Lógica: Multiplicación acumulativa en bucle para cálculo factorial\n\n// 8. Función que encuentra el mayor de dos números\nint encontrarMayor(int a, int b) {\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n// Lógica: Comparación condicional para determinar valor máximo\n\n// 9. Función que suma precios de una lista\ndouble calcularTotal(List<double> precios) {\n  double total = 0;\n  for (double precio in precios) {\n    total += precio;\n  }\n  return total;\n}\n// Lógica: Iteración con acumulador para suma de elementos de lista\n\n// 10. Función que convierte texto a mayúsculas\nString aMayusculas(String texto) {\n  return texto.toUpperCase();\n}\n// Lógica: Transformación de string a mayúsculas usando método nativo\n\n// =============================================\n// BLOQUE 2: Tipos de argumentos\n// =============================================\n\n// 11. Función con parámetro opcional\nvoid saludarOpcional([String nombre = \"invitado\"]) {\n  print('Hola, $nombre!');\n}\n// Lógica: Parámetro opcional con valor por defecto para flexibilidad\n\n// 12. Función con parámetros nombrados\nvoid mostrarDatos({required String nombre, required int edad}) {\n  print('Nombre: $nombre, Edad: $edad');\n}\n// Lógica: Parámetros nombrados para llamadas más legibles y explícitas\n\n// 13. Función con validación de parámetro opcional\nvoid mensajeError([String? mensaje]) {\n  if (mensaje == null) {\n    print('Error: No se proporcionó mensaje');\n  } else {\n    print('Mensaje: $mensaje');\n  }\n}\n// Lógica: Validación de null para parámetros opcionales no proporcionados\n\n// 14. Función con parámetro con valor por defecto\nvoid mostrarInfo(String nombre, int edad, [String pais = \"España\"]) {\n  print('$nombre, $edad años, de $pais');\n}\n// Lógica: Parámetro posicional opcional con valor predeterminado\n\n// 15. Función que verifica si lista contiene número\nbool contieneNumero(List<int> lista, int numero) {\n  return lista.contains(numero);\n}\n// Lógica: Uso de método contains para búsqueda en colección\n\n// 16. Función que repite texto\nvoid repetirTexto(String texto, [int repeticiones = 1]) {\n  for (int i = 0; i < repeticiones; i++) {\n    print(texto);\n  }\n}\n// Lógica: Bucle controlado por parámetro opcional para repeticiones\n\n// 17. Función con múltiples parámetros opcionales\ndouble mediaOpcional(int a, [int? b, int? c]) {\n  int suma = a;\n  int contador = 1;\n  \n  if (b != null) {\n    suma += b;\n    contador++;\n  }\n  if (c != null) {\n    suma += c;\n    contador++;\n  }\n  \n  return suma / contador;\n}\n// Lógica: Suma condicional de parámetros opcionales no nulos\n\n// 18. Función que accede a elemento de lista con control de rango\ndynamic obtenerElemento(List lista, int indice) {\n  if (indice >= 0 && indice < lista.length) {\n    return lista[indice];\n  } else {\n    return 'Índice fuera de rango';\n  }\n}\n// Lógica: Validación de límites antes de acceso a elemento de lista\n\n// 19. Función con múltiples parámetros nombrados\nString crearPerfil({required String nombre, required int edad, bool activo = true}) {\n  String estado = activo ? 'activo' : 'inactivo';\n  return '$nombre, $edad años - $estado';\n}\n// Lógica: Interpolación con parámetros nombrados y valor por defecto\n\n// 20. Función que combina parámetros posicionales y nombrados\nvoid mostrarCombinado(String nombre, {int edad = 0, String ciudad = \"Desconocida\"}) {\n  print('$nombre, $edad años, de $ciudad');\n}\n// Lógica: Mix de parámetros posicionales obligatorios y nombrados opcionales\n\n// =============================================\n// BLOQUE 3: Funciones async, await y Future\n// =============================================\n\n// 21. Función async que devuelve mensaje después de delay\nFuture<String> mensajeConRetraso() async {\n  await Future.delayed(Duration(seconds: 2));\n  return \"Mensaje listo después de 2 segundos\";\n}\n// Lógica: Espera asíncrona con delayed antes de retornar resultado\n\n// 22. Función async que simula descarga\nFuture<void> simularDescarga() async {\n  print('Iniciando descarga...');\n  await Future.delayed(Duration(seconds: 3));\n  print('Descarga completada');\n}\n// Lógica: Simulación de proceso largo con await para pausa controlada\n\n// 23. Función async que calcula cuadrado con retraso\nFuture<int> cuadradoConRetraso(int numero) async {\n  await Future.delayed(Duration(seconds: 1));\n  return numero * numero;\n}\n// Lógica: Cálculo sencillo precedido por espera asíncrona\n\n// 24. Función que combina sync y async\nFuture<int> procesarNumero(int numero) async {\n  // Función sincrónica auxiliar\n  int duplicar(int n) => n * 2;\n  \n  int resultado = duplicar(numero);\n  await Future.delayed(Duration(seconds: 1));\n  return resultado;\n}\n// Lógica: Integración de lógica síncrona dentro de flujo asíncrono\n\n// 25. Función async que procesa lista con pausas\nFuture<void> procesarLista(List<String> elementos) async {\n  for (String elemento in elementos) {\n    print('Procesando: $elemento');\n    await Future.delayed(Duration(seconds: 1));\n  }\n  print('Procesamiento completado');\n}\n// Lógica: Iteración con pausas asíncronas entre cada elemento\n\n// 26. Función que espera múltiples Futures\nFuture<String> combinarFutures() async {\n  String dato1 = await _obtenerDato1();\n  String dato2 = await _obtenerDato2();\n  String dato3 = await _obtenerDato3();\n  \n  return '$dato1 - $dato2 - $dato3';\n}\n\nFuture<String> _obtenerDato1() async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Dato1';\n}\n\nFuture<String> _obtenerDato2() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Dato2';\n}\n\nFuture<String> _obtenerDato3() async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Dato3';\n}\n// Lógica: Ejecución secuencial de múltiples operaciones asíncronas\n\n// 27. Función async que calcula área de círculo\nFuture<double> areaCirculoConRetraso(double radio) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 3.1416 * radio * radio;\n}\n// Lógica: Cálculo matemático con simulación de procesamiento largo\n\n// 28. Función async que simula validación de login\nFuture<String> validarLogin(String usuario, String contrasena) async {\n  await Future.delayed(Duration(seconds: 2));\n  \n  if (usuario == 'admin' && contrasena == '1234') {\n    return 'Acceso permitido';\n  } else {\n    return 'Acceso denegado';\n  }\n}\n// Lógica: Validación condicional después de simulación de delay\n\n// 29. Función con bucle y llamadas async\nFuture<void> procesoPorPasos(List<String> pasos) async {\n  for (int i = 0; i < pasos.length; i++) {\n    print('Paso ${i + 1}: ${pasos[i]}');\n    await _simularPaso();\n  }\n  print('Proceso completado');\n}\n\nFuture<void> _simularPaso() async {\n  await Future.delayed(Duration(seconds: 1));\n}\n// Lógica: Control secuencial de pasos con esperas asíncronas\n\n// 30. Función main async que coordina tareas\nFuture<void> main() async {\n  print('=== INICIANDO PROGRAMA PRINCIPAL ===');\n  \n  await ejecutarEjerciciosAsync();\n  \n  print('=== PROGRAMA COMPLETADO ===');\n}\n\n// =============================================\n// BLOQUE 4: Manejo de errores con try y catch\n// =============================================\n\n// 31. División con manejo de errores\nvoid dividirConManejo(int a, int b) {\n  try {\n    double resultado = a / b;\n    print('Resultado: $resultado');\n  } catch (e) {\n    print('Error: No se puede dividir por cero');\n  }\n}\n// Lógica: Captura de excepción por división entre cero\n\n// 32. Función con retorno seguro de cociente\ndouble? cocienteSeguro(int a, int b) {\n  try {\n    return a / b;\n  } catch (e) {\n    return null;\n  }\n}\n// Lógica: Retorno condicional null en caso de error\n\n// 33. Conversión de texto a número con manejo de errores\nint? convertirTextoANumero(String texto) {\n  try {\n    return int.parse(texto);\n  } catch (e) {\n    print('Error: \"$texto\" no es un número válido');\n    return null;\n  }\n}\n// Lógica: Validación de formato numérico con parse protegido\n\n// 34. Lectura segura de número desde teclado\nint? leerNumeroSeguro(String mensaje) {\n  print(mensaje);\n  try {\n    String? input = stdin.readLineSync();\n    return int.parse(input!);\n  } catch (e) {\n    print('Error: Entrada no válida');\n    return null;\n  }\n}\n// Lógica: Captura de errores en entrada de usuario con parse\n\n// 35. Acceso seguro a elemento de lista\ndynamic accesoListaSeguro(List lista, int indice) {\n  try {\n    return lista[indice];\n  } catch (e) {\n    return 'Error: Índice $indice fuera de rango (0-${lista.length - 1})';\n  }\n}\n// Lógica: Protección contra acceso fuera de límites de lista\n\n// 36. Simulación de apertura de archivo con error\nvoid simularAbrirArchivo(String nombreArchivo) {\n  try {\n    if (!nombreArchivo.endsWith('.txt')) {\n      throw Exception('Archivo no encontrado: $nombreArchivo');\n    }\n    print('Archivo $nombreArchivo abierto correctamente');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n// Lógica: Lanzamiento y captura de excepción personalizada\n\n// 37. Cálculo de raíz cuadrada con validación\ndouble? raizCuadradaSegura(double numero) {\n  try {\n    if (numero < 0) {\n      throw Exception('No se puede calcular raíz de número negativo');\n    }\n    return double.parse((sqrt(numero)).toStringAsFixed(2));\n  } catch (e) {\n    print('Error: $e');\n    return null;\n  }\n}\n// Lógica: Validación previa y lanzamiento de excepción controlada\n\n// 38. Función async con manejo de error en Future\nFuture<void> futureConError() async {\n  try {\n    await Future.delayed(Duration(seconds: 1));\n    throw Exception('Error simulado en Future');\n  } catch (e) {\n    print('Error capturado: $e');\n  }\n}\n// Lógica: Captura de excepciones en operaciones asíncronas\n\n// 39. Manejo de diferentes tipos de excepciones\nvoid manejoMultipleErrores(String texto, int indice) {\n  try {\n    int numero = int.parse(texto);\n    List<int> lista = [1, 2, 3];\n    print('Elemento: ${lista[indice]}');\n    print('Número: $numero');\n  } on FormatException {\n    print('Error: Formato de texto inválido');\n  } on RangeError catch (e) {\n    print('Error de rango: $e');\n  } catch (e) {\n    print('Error inesperado: $e');\n  }\n}\n// Lógica: Captura específica por tipo de excepción\n\n// 40. Análisis detallado de errores\nvoid analizarError(dynamic operacionPeligrosa) {\n  try {\n    operacionPeligrosa();\n  } catch (e) {\n    if (e is FormatException) {\n      print('Error de formato: Verifique la entrada');\n    } else if (e is RangeError) {\n      print('Error de rango: Índice fuera de límites');\n    } else if (e is IntegerDivisionByZeroException) {\n      print('Error matemático: División por cero');\n    } else {\n      print('Error desconocido: $e');\n    }\n  }\n}\n// Lógica: Clasificación de errores por tipo para mensajes específicos\n\n// =============================================\n// FUNCIÓN PRINCIPAL PARA EJECUTAR EJERCICIOS\n// =============================================\n\nFuture<void> ejecutarEjerciciosAsync() async {\n  print('\\n--- BLOQUE 1: Funciones básicas ---');\n  holaMundo();\n  saludarPersonalizado('Ana');\n  print('Suma: ${sumar(5, 3)}');\n  print('Promedio: ${calcularPromedio(7.5, 8.0, 6.5)}');\n  print('¿Es 10 par? ${esPar(10)}');\n  print('Caracteres en \"Hola\": ${contarCaracteres(\"Hola\")}');\n  print('Factorial de 5: ${factorial(5)}');\n  print('Mayor entre 8 y 12: ${encontrarMayor(8, 12)}');\n  \n  List<double> precios = [10.5, 25.0, 8.75];\n  print('Total precios: ${calcularTotal(precios)}');\n  print('Mayúsculas: ${aMayusculas(\"hola mundo\")}');\n  \n  print('\\n--- BLOQUE 2: Tipos de argumentos ---');\n  saludarOpcional();\n  saludarOpcional('Carlos');\n  mostrarDatos(nombre: 'María', edad: 25);\n  mensajeError();\n  mensajeError('Todo bien');\n  mostrarInfo('Juan', 30);\n  mostrarInfo('Lisa', 28, 'Francia');\n  \n  List<int> numeros = [1, 2, 3, 4, 5];\n  print('¿Contiene 3? ${contieneNumero(numeros, 3)}');\n  repetirTexto('Hola', 3);\n  print('Media opcional: ${mediaOpcional(10, 20, 30)}');\n  print('Elemento lista: ${obtenerElemento(numeros, 2)}');\n  print('Perfil: ${crearPerfil(nombre: 'Pedro', edad: 35, activo: true)}');\n  mostrarCombinado('Ana', edad: 25, ciudad: 'Madrid');\n  \n  print('\\n--- BLOQUE 3: Funciones async ---');\n  String mensaje = await mensajeConRetraso();\n  print(mensaje);\n  \n  await simularDescarga();\n  \n  int cuadrado = await cuadradoConRetraso(5);\n  print('Cuadrado: $cuadrado');\n  \n  int procesado = await procesarNumero(7);\n  print('Número procesado: $procesado');\n  \n  await procesarLista(['A', 'B', 'C']);\n  \n  String datosCombinados = await combinarFutures();\n  print('Datos combinados: $datosCombinados');\n  \n  double area = await areaCirculoConRetraso(5.0);\n  print('Área círculo: $area');\n  \n  String login = await validarLogin('admin', '1234');\n  print('Validación login: $login');\n  \n  await procesoPorPasos(['Inicio', 'Proceso', 'Fin']);\n  \n  print('\\n--- BLOQUE 4: Manejo de errores ---');\n  dividirConManejo(10, 2);\n  dividirConManejo(10, 0);\n  \n  print('Cociente seguro: ${cocienteSeguro(10, 2)}');\n  print('Cociente seguro: ${cocienteSeguro(10, 0)}');\n  \n  print('Número convertido: ${convertirTextoANumero(\"123\")}');\n  print('Número convertido: ${convertirTextoANumero(\"abc\")}');\n  \n  // Simulación de lectura (comentado para no interrumpir flujo)\n  // int? numeroLeido = leerNumeroSeguro('Ingresa un número:');\n  // print('Número leído: $numeroLeido');\n  \n  print('Acceso lista: ${accesoListaSeguro(numeros, 2)}');\n  print('Acceso lista: ${accesoListaSeguro(numeros, 10)}');\n  \n  simularAbrirArchivo('documento.txt');\n  simularAbrirArchivo('imagen.jpg');\n  \n  print('Raíz cuadrada: ${raizCuadradaSegura(16)}');\n  print('Raíz cuadrada: ${raizCuadradaSegura(-4)}');\n  \n  await futureConError();\n  \n  manejoMultipleErrores('123', 1);\n  manejoMultipleErrores('abc', 1);\n  manejoMultipleErrores('123', 10);\n  \n  analizarError(() => int.parse('123'));\n  analizarError(() => int.parse('abc'));\n}"
        }
    ]
}