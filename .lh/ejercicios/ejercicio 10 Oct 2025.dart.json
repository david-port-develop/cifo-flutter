{
    "sourceFile": "ejercicios/ejercicio 10 Oct 2025.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760531120633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760531120633,
            "name": "Commit-0",
            "content": "import 'dart:io';\nimport 'dart:math';\n\n// =============================================\n// BLOQUE 1: Funciones básicas y con retorno\n// =============================================\n\n// 1. Función sin parámetros ni retorno\nvoid holaMundo() {\n  print('Hola, mundo');\n}\n// Lógica: Función void simple que ejecuta un print básico\n\n// 2. Función con parámetro para saludo personalizado\nvoid saludarPersonalizado(String nombre) {\n  print('Hola, $nombre! Bienvenido/a');\n}\n// Lógica: Concatenación de string con parámetro para personalización\n\n// 3. Función que retorna suma de dos números\nint sumar(int a, int b) {\n  return a + b;\n}\n\n// Lógica: Operación aritmética básica con retorno de resultado\n//Todas las funciones que solo tienen un return se puede usar la notación de flecha, por ejemplo:\nsumarflechas(int a, int b) => a + b;\n\n// 4. Función que calcula promedio de tres notas\ndouble calcularPromedio(double a, double b, double c) {\n  return (a + b + c) / 3;\n}\n// Lógica: Cálculo de media aritmética con división por cantidad\n\n// 5. Función que verifica si un número es par\nbool esPar(int numero) {\n  return numero % 2 == 0;\n}\n// Lógica: Uso de módulo para determinar paridad con retorno booleano\n\n// 6. Función que cuenta caracteres de un texto\nint contarCaracteres(String texto) {\n  return texto.length;\n}\n// Lógica: Acceso a propiedad length para obtener tamaño del string\n\n// 7. Función que calcula factorial\nint factorial(int n) {\n  int resultado = 1;\n  for (int i = 1; i <= n; i++) {\n    resultado *= i;\n  }\n  return resultado;\n}\n// Lógica: Multiplicación acumulativa en bucle para cálculo factorial\n\n// 8. Función que encuentra el mayor de dos números\nint encontrarMayor(int a, int b) {\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n// Lógica: Comparación condicional para determinar valor máximo\n\n// 9. Función que suma precios de una lista\ndouble calcularTotal(List<double> precios) {\n  double total = 0;\n  for (double precio in precios) {\n    total += precio;\n  }\n  return total;\n}\n// Lógica: Iteración con acumulador para suma de elementos de lista\n\n// 10. Función que convierte texto a mayúsculas\nString aMayusculas(String texto) {\n  return texto.toUpperCase();\n}\n// Lógica: Transformación de string a mayúsculas usando método nativo\n\n// =============================================\n// BLOQUE 2: Tipos de argumentos\n// =============================================\n\n// 1. Función con parámetro opcional\nvoid saludarOpcional([String? nombre]) {\n  if (nombre == null || nombre.isEmpty) {\n    print('Hola desconocido!');\n  } else {\n    print('Hola $nombre!');\n  }\n}\n// Lógica: Validación de null y string vacío para parámetro opcional\n\n// 2. Función con parámetros nombrados\nvoid mostrarDatos({required String nombre, required int edad}) {\n  // Validar datos antes de usarlos\n  if (nombre.isEmpty) {\n    print('Error: El nombre no puede estar vacío');\n    return;\n  }\n  if (edad < 0 || edad > 150) {\n    print('Error: La edad debe estar entre 0 y 150 años');\n    return;\n  }\n  print('Nombre: $nombre, Edad: $edad');\n}\n// Lógica: Validación de rangos y valores vacíos en parámetros required\n\n// 3. Función con validación de parámetro opcional\nvoid mensajeError([String? mensaje]) {\n  if (mensaje == null || mensaje.isEmpty) {\n    print('Error: No se proporcionó mensaje válido');\n  } else {\n    print('Mensaje: $mensaje');\n  }\n}\n// Lógica: Validación de null y string vacío\n\n// 4. Función con parámetro con valor por defecto\nvoid mostrarInfo(String nombre, int edad, [String? pais]) {\n  // Validar parámetros obligatorios\n  if (nombre.isEmpty) {\n    print('Error: El nombre es obligatorio');\n    return;\n  }\n  if (edad <= 0) {\n    print('Error: La edad debe ser positiva');\n    return;\n  }\n\n  // Usar valor por defecto si no se proporciona país\n  String paisMostrar = pais ?? \"España\";\n  print('$nombre, $edad años, de $paisMostrar');\n}\n// Lógica: Validación de parámetros obligatorios y manejo de opcionales\n\n// 5. Función que verifica si lista contiene número\nbool contieneNumero(List<int>? lista, int numero) {\n  if (lista == null || lista.isEmpty) {\n    print('Error: La lista está vacía o es nula');\n    return false;\n  }\n  return lista.contains(numero);\n}\n// Lógica: Validación de lista nula o vacía\n\n// 6. Función que repite texto\nvoid repetirTexto(String texto, [int? repeticiones]) {\n  // Validar texto\n  if (texto.isEmpty) {\n    print('Error: El texto no puede estar vacío');\n    return;\n  }\n\n  // Usar valor por defecto si no se proporciona\n  int repeticionesValidas = repeticiones ?? 1;\n\n  // Validar repeticiones\n  if (repeticionesValidas <= 0) {\n    print('Error: Las repeticiones deben ser mayor a 0');\n    return;\n  }\n\n  for (int i = 0; i < repeticionesValidas; i++) {\n    print(texto);\n  }\n}\n// Lógica: Validación completa de todos los parámetros\n\n// 7. Función con múltiples parámetros opcionales\ndouble? mediaOpcional([int? a, int? b, int? c]) {\n  List<int> numeros = [];\n\n  // Solo agregar números no nulos\n  if (a != null) numeros.add(a);\n  if (b != null) numeros.add(b);\n  if (c != null) numeros.add(c);\n\n  // Validar que tenemos al menos un número\n  if (numeros.isEmpty) {\n    print('Error: Se requiere al menos un número para calcular la media');\n    return null;\n  }\n\n  // Calcular suma\n  int suma = 0;\n  for (int numero in numeros) {\n    suma += numero;\n  }\n\n  return suma / numeros.length;\n}\n// Lógica: Validación de que al menos un parámetro no sea null\n\n// 8. Función que accede a elemento de lista con control de rango\ndynamic obtenerElemento(List? lista, int indice) {\n  if (lista == null || lista.isEmpty) {\n    return 'Error: La lista está vacía o es nula';\n  }\n  if (indice < 0 || indice >= lista.length) {\n    return 'Error: Índice $indice fuera de rango (0-${lista.length - 1})';\n  }\n  return lista[indice];\n}\n// Lógica: Validación de lista nula/vacía y rango de índice\n\n// 9. Función con múltiples parámetros nombrados\nString crearPerfil({String? nombre, int? edad, bool? activo}) {\n  // Validar parámetros requeridos\n  if (nombre == null || nombre.isEmpty) {\n    return 'Error: El nombre es obligatorio';\n  }\n  if (edad == null || edad < 0 || edad > 150) {\n    return 'Error: La edad debe estar entre 0 y 150 años';\n  }\n\n  // Valor por defecto para activo\n  bool estadoActivo = activo ?? true;\n  String estado = estadoActivo ? 'activo' : 'inactivo';\n\n  return '$nombre, $edad años - $estado';\n}\n// Lógica: Validación completa de parámetros nombrados\n\n// 10. Función que combina parámetros posicionales y nombrados\nvoid mostrarCombinado(String nombre, {int? edad, String? ciudad}) {\n  // Validar parámetro obligatorio\n  if (nombre.isEmpty) {\n    print('Error: El nombre es obligatorio');\n    return;\n  }\n\n  // Valores por defecto para parámetros nombrados\n  int edadMostrar = edad ?? 0;\n  String ciudadMostrar = ciudad ?? \"Desconocida\";\n\n  // Validar rangos\n  if (edadMostrar < 0) {\n    print('Error: La edad no puede ser negativa');\n    return;\n  }\n\n  print('$nombre, $edadMostrar años, de $ciudadMostrar');\n}\n// Lógica: Validación de parámetro obligatorio y manejo de opcionales\n\n// =============================================\n// BLOQUE 3: Funciones async, await y Future\n// =============================================\n\n// 1. Función async que devuelve mensaje después de delay\nFuture<String> mensajeConRetraso() async {\n  await Future.delayed(Duration(seconds: 2));\n  return \"Mensaje listo después de 2 segundos\";\n}\n// Lógica: Espera asíncrona con delayed antes de retornar resultado\n\n// 2. Función async que simula descarga\nFuture<void> simularDescarga() async {\n  print('Iniciando descarga...');\n  await Future.delayed(Duration(seconds: 5));\n  print('Descarga completada');\n}\n// Lógica: Simulación de proceso largo con await para pausa controlada\n\n// 3. Función async que calcula cuadrado con retraso\nFuture<int> cuadradoConRetraso(int numero) async {\n  await Future.delayed(Duration(seconds: 1));\n  return numero * numero;\n}\n// Lógica: Cálculo sencillo precedido por espera asíncrona\n\n// 4. Función que combina sync y async\nFuture<int> procesarNumero(int numero) async {\n  // Función sincrónica auxiliar\n  int duplicar(int n) => n * 2;\n\n  int resultado = duplicar(numero);\n  await Future.delayed(Duration(seconds: 1));\n  return resultado;\n}\n// Lógica: Integración de lógica síncrona dentro de flujo asíncrono\n\n// 5. Función async que procesa lista con pausas\nFuture<void> procesarLista(List<String> elementos) async {\n  for (String elemento in elementos) {\n    print('Procesando: $elemento');\n    await Future.delayed(Duration(seconds: 1));\n  }\n  print('Procesamiento completado');\n}\n// Lógica: Iteración con pausas asíncronas entre cada elemento\n\n// 6. Función que espera múltiples Futures\nFuture<String> combinarFutures() async {\n  String dato1 = await _obtenerDato1();\n  String dato2 = await _obtenerDato2();\n  String dato3 = await _obtenerDato3();\n\n  return '$dato1 - $dato2 - $dato3';\n}\n\nFuture<String> _obtenerDato1() async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Dato1';\n}\n\nFuture<String> _obtenerDato2() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'Dato2';\n}\n\nFuture<String> _obtenerDato3() async {\n  await Future.delayed(Duration(seconds: 1));\n  return 'Dato3';\n}\n// Lógica: Ejecución secuencial de múltiples operaciones asíncronas\n\n// 7. Función async que calcula área de círculo\nFuture<double> areaCirculoConRetraso(double radio) async {\n  await Future.delayed(Duration(seconds: 2));\n  return 3.1416 * radio * radio;\n}\n// Lógica: Cálculo matemático con simulación de procesamiento largo\n\n// 8. Función async que simula validación de login\nFuture<String> validarLogin(String usuario, String contrasena) async {\n  await Future.delayed(Duration(seconds: 2));\n\n  if (usuario == 'admin' && contrasena == '1234') {\n    return 'Acceso permitido';\n  } else {\n    return 'Acceso denegado';\n  }\n}\n// Lógica: Validación condicional después de simulación de delay\n\n// 9. Función con bucle y llamadas async\nFuture<void> procesoPorPasos(List<String> pasos) async {\n  for (int i = 0; i < pasos.length; i++) {\n    print('Paso ${i + 1}: ${pasos[i]}');\n    await _simularPaso();\n  }\n  print('Proceso completado');\n}\n\nFuture<void> _simularPaso() async {\n  await Future.delayed(Duration(seconds: 1));\n}\n// Lógica: Control secuencial de pasos con esperas asíncronas\n\n// 10. Función main async que coordina tareas\nFuture<void> main() async {\n  print('=== INICIANDO PROGRAMA PRINCIPAL ===');\n\n  await ejecutarEjerciciosAsync();\n\n  print('=== PROGRAMA COMPLETADO ===');\n}\n\n// =============================================\n// BLOQUE 4: Manejo de errores con try y catch\n// =============================================\n\n// 1. División con manejo de errores\nvoid dividirConManejo(int a, int b) {\n  try {\n    double resultado = a / b;\n    print('Resultado: $resultado');\n  } catch (e) {\n    print('Error: No se puede dividir por cero');\n  }\n}\n// Lógica: Captura de excepción por división entre cero\n\n// 2. Función con retorno seguro de cociente\ndouble? cocienteSeguro(int a, int b) {\n  try {\n    return a / b;\n  } catch (e) {\n    return null;\n  }\n}\n// Lógica: Retorno condicional null en caso de error\n\n// 3. Conversión de texto a número con manejo de errores\nint? convertirTextoANumero(String texto) {\n  try {\n    return int.parse(texto);\n  } catch (e) {\n    print('Error: \"$texto\" no es un número válido');\n    return null;\n  }\n}\n// Lógica: Validación de formato numérico con parse protegido\n\n// 4. Lectura segura de número desde teclado\nint? leerNumeroSeguro(String mensaje) {\n  print(mensaje);\n  try {\n    String? input = stdin.readLineSync();\n    return int.parse(input!);\n  } catch (e) {\n    print('Error: Entrada no válida');\n    return null;\n  }\n}\n// Lógica: Captura de errores en entrada de usuario con parse\n\n// 5. Acceso seguro a elemento de lista\ndynamic accesoListaSeguro(List lista, int indice) {\n  try {\n    return lista[indice];\n  } catch (e) {\n    return 'Error: Índice $indice fuera de rango (0-${lista.length - 1})';\n  }\n}\n// Lógica: Protección contra acceso fuera de límites de lista\n\n// 6. Simulación de apertura de archivo con error\nvoid simularAbrirArchivo(String nombreArchivo) {\n  try {\n    if (!nombreArchivo.endsWith('.txt')) {\n      throw Exception('Archivo no encontrado: $nombreArchivo');\n    }\n    print('Archivo $nombreArchivo abierto correctamente');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n// Lógica: Lanzamiento y captura de excepción personalizada\n\n// 7. Cálculo de raíz cuadrada con validación\ndouble? raizCuadradaSegura(double numero) {\n  try {\n    if (numero < 0) {\n      throw Exception('No se puede calcular raíz de número negativo');\n    }\n    return double.parse((sqrt(numero)).toStringAsFixed(2));\n  } catch (e) {\n    print('Error: $e');\n    return null;\n  }\n}\n// Lógica: Validación previa y lanzamiento de excepción controlada\n\n// 8. Función async con manejo de error en Future\nFuture<void> futureConError() async {\n  try {\n    await Future.delayed(Duration(seconds: 1));\n    throw Exception('Error simulado en Future');\n  } catch (e) {\n    print('Error capturado: $e');\n  }\n}\n// Lógica: Captura de excepciones en operaciones asíncronas\n\n// 9. Manejo de diferentes tipos de excepciones\nvoid manejoMultipleErrores(String texto, int indice) {\n  try {\n    int numero = int.parse(texto);\n    List<int> lista = [1, 2, 3];\n    print('Elemento: ${lista[indice]}');\n    print('Número: $numero');\n  } on FormatException {\n    print('Error: Formato de texto inválido');\n  } on RangeError catch (e) {\n    print('Error de rango: $e');\n  } catch (e) {\n    print('Error inesperado: $e');\n  }\n}\n// Lógica: Captura específica por tipo de excepción\n\n// 10. Análisis detallado de errores\nvoid analizarError(dynamic operacionPeligrosa) {\n  try {\n    operacionPeligrosa();\n  } catch (e) {\n    if (e is FormatException) {\n      print('Error de formato: Verifique la entrada');\n    } else if (e is RangeError) {\n      print('Error de rango: Índice fuera de límites');\n    } else if (e is IntegerDivisionByZeroException) {\n      print('Error matemático: División por cero');\n    } else {\n      print('Error desconocido: $e');\n    }\n  }\n}\n// Lógica: Clasificación de errores por tipo para mensajes específicos\n\n// =============================================\n// FUNCIÓN PRINCIPAL PARA EJECUTAR EJERCICIOS\n// =============================================\n\n//aprovecho la función principal para hacer el ejercicio 10 del BLOQUE 3\nFuture<void> ejecutarEjerciciosAsync() async {\n  print('\\n--- BLOQUE 1: Funciones básicas ---');\n  holaMundo();\n  saludarPersonalizado('Ana');\n  print('Suma: ${sumar(5, 3)}');\n  print('Promedio: ${calcularPromedio(7.5, 8.0, 6.5)}');\n  print('¿Es 10 par? ${esPar(10)}');\n  print('Caracteres en \"Hola\": ${contarCaracteres(\"Hola\")}');\n  print('Factorial de 5: ${factorial(5)}');\n  print('Mayor entre 8 y 12: ${encontrarMayor(8, 12)}');\n\n  List<double> precios = [10.5, 25.0, 8.75];\n  print('Total precios: ${calcularTotal(precios)}');\n  print('Mayúsculas: ${aMayusculas(\"hola mundo\")}');\n\n  print('\\n--- BLOQUE 2: Tipos de argumentos ---');\n  saludarOpcional();\n  saludarOpcional('Carlos');\n  mostrarDatos(nombre: 'María', edad: 25);\n  //Sin texto\n  mensajeError();\n  //Con texto\n  mensajeError('Todo bien');\n  mostrarInfo('Juan', 30);\n  mostrarInfo('Lisa', 28, 'Francia');\n\n  List<int> numeros = [1, 2, 3, 4, 5];\n  print('¿Contiene 3? ${contieneNumero(numeros, 3)}');\n  repetirTexto('Hola nena', 3);\n  print(\n      'Media en función con parámetros opcionales: ${mediaOpcional(10, 20, 30)}');\n  print('Elemento lista: ${obtenerElemento(numeros, 2)}');\n  print('Perfil: ${crearPerfil(nombre: 'Pedro', edad: 35, activo: true)}');\n  mostrarCombinado('Ana', edad: 25, ciudad: 'Madrid');\n\n  print('\\n--- BLOQUE 3: Funciones async ---');\n//1\n  String mensaje = await mensajeConRetraso();\n  print(mensaje);\n//2\n  await simularDescarga();\n//3\n  int cuadrado = await cuadradoConRetraso(5);\n  print('Cuadrado: $cuadrado');\n//4\n  int procesado = await procesarNumero(7);\n  print('Número procesado: $procesado');\n//5\n  await procesarLista(['A', 'B', 'C']);\n//6\n  String datosCombinados = await combinarFutures();\n  print('Datos combinados: $datosCombinados');\n//7\n  double area = await areaCirculoConRetraso(5.0);\n  print('Área círculo: $area');\n//8\n  String login = await validarLogin('admin', '1234');\n  print('Validación login: $login');\n//9\n  await procesoPorPasos(['Inicio', 'Proceso', 'Fin']);\n\n  print('\\n--- BLOQUE 4: Manejo de errores ---');\n  //1\n  dividirConManejo(10, 2);\n  dividirConManejo(10, 0);\n//2\n  print('Cociente seguro: ${cocienteSeguro(10, 2)}');\n  print('Cociente seguro: ${cocienteSeguro(10, 0)}');\n\n  print('Número convertido: ${convertirTextoANumero(\"123\")}');\n  print('Número convertido: ${convertirTextoANumero(\"abc\")}');\n\n  // Simulación de lectura (comentado para no interrumpir flujo)\n  // int? numeroLeido = leerNumeroSeguro('Ingresa un número:');\n  // print('Número leído: $numeroLeido');\n\n  print('Acceso lista: ${accesoListaSeguro(numeros, 2)}');\n  print('Acceso lista: ${accesoListaSeguro(numeros, 10)}');\n\n  simularAbrirArchivo('documento.txt');\n  simularAbrirArchivo('imagen.jpg');\n\n  print('Raíz cuadrada: ${raizCuadradaSegura(16)}');\n  print('Raíz cuadrada: ${raizCuadradaSegura(-4)}');\n\n  await futureConError();\n\n  manejoMultipleErrores('123', 1);\n  manejoMultipleErrores('abc', 1);\n  manejoMultipleErrores('123', 10);\n\n  analizarError(() => int.parse('123'));\n  analizarError(() => int.parse('abc'));\n}\n"
        }
    ]
}