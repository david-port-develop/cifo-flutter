{
    "sourceFile": "ejercicios/ejercicio 15 Oct 2025.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1760603869496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760606946291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,191 +1,157 @@\n // -----------------------------------------------------------\n-// 1. Clase base Animal (convertida a abstracta en el ejercicio 9)\n+// 9. Clase abstracta Animal y 6. Encapsulación\n // -----------------------------------------------------------\n abstract class Animal {\n-  // Campo para el nombre\n   String nombre;\n-  // 6. Campo privado para la edad\n-  int _edad = 0;\n+  int _edad = 0; // 6. Campo privado\n \n-  // 1. Constructor\n-  Animal(this.nombre);\n+  Animal(this.nombre); // 1. Constructor\n \n-  // 9. Método abstracto: sin implementación en la clase base.\n+  // 9. Método abstracto: sin implementación\n   void mover();\n \n-  // 6. Getter para _edad\n+  // 6. Getter\n   int get edad => _edad;\n \n-  // 6. Setter para _edad (impide valores negativos)\n+  // 6. Setter con validación\n   set edad(int e) {\n     if (e >= 0) {\n       _edad = e;\n     } else {\n       print(\"Error: La edad no puede ser negativa.\");\n     }\n   }\n \n-  // 8. Sobrescritura básica de toString()\n+  // 8. Sobrescritura de toString()\n   @override\n   String toString() => \"Un $nombre de tipo ${runtimeType.toString()}\";\n }\n \n // -----------------------------------------------------------\n-// 2. Subclases Mammal, Bird, Fish\n+// 4. Mixins para Comportamientos\n // -----------------------------------------------------------\n+mixin Walk {\n+  void caminar() => print(\"Caminando sobre la tierra.\");\n+}\n+\n+mixin Swim {\n+  void nadar() => print(\"Nadando en el agua.\");\n+}\n+\n+mixin Fly {\n+  void volar() => print(\"Volando por el aire.\");\n+}\n+\n+// -----------------------------------------------------------\n+// 2. 3. Subclases Mammal, Bird, Fish\n+// -----------------------------------------------------------\n class Mammal extends Animal {\n-  // 3. Constructor que pasa 'nombre' al constructor de la clase base.\n-  Mammal(super.nombre);\n+  Mammal(super.nombre); // 3. super()\n \n-  // 2. Redefinición obligatoria de mover()\n-  @override\n-  void mover() => print(\"$nombre (Mamífero) camina sobre la tierra\");\n+  @override // 2. Redefinición obligatoria (por clase abstracta)\n+  void mover() => print(\"$nombre (Mamífero) se mueve típicamente por tierra.\");\n }\n \n class Bird extends Animal {\n   Bird(super.nombre);\n \n-  // 2. Redefinición obligatoria de mover()\n-  @override\n-  void mover() => print(\"$nombre (Ave) vuela por el aire\");\n+  @override // 2. Redefinición obligatoria\n+  void mover() => print(\"$nombre (Ave) se mueve típicamente volando.\");\n }\n \n class Fish extends Animal {\n   Fish(super.nombre);\n \n-  // 2. Redefinición obligatoria de mover()\n-  @override\n-  void mover() => print(\"$nombre (Pez) nada en el agua\");\n+  @override // 2. Redefinición obligatoria\n+  void mover() => print(\"$nombre (Pez) se mueve típicamente nadando.\");\n }\n \n // -----------------------------------------------------------\n-// 4. Mixins\n+// 4. 5. 10. Clases Concretas con Mixins\n // -----------------------------------------------------------\n-// Los mixins proporcionan una forma de reutilizar el código de la clase\n-// en múltiples jerarquías de clases.\n-mixin Walk {\n-  void caminar() => print(\"Caminando...\");\n-}\n \n-mixin Swim {\n-  void nadar() => print(\"Nadando...\");\n-}\n-\n-mixin Fly {\n-  void volar() => print(\"Volando...\");\n-}\n-\n-// -----------------------------------------------------------\n-// Clases concretas (ejercicios 4, 5, 8, 10)\n-// -----------------------------------------------------------\n-\n-// Clase Cat (Mamífero simple)\n+// Cat: Mamífero simple\n class Cat extends Mammal {\n   Cat(super.nombre);\n-\n-  // 8. Sobrescritura de toString()\n   @override\n-  String toString() => \"Soy un Gato llamado $nombre\";\n+  String toString() => \"Soy un Gato llamado $nombre\"; // 8.\n }\n \n-// 4. Bat: hereda de Mammal e implementa Walk y Fly.\n+// 4. Bat: Mammal + Walk, Fly\n class Bat extends Mammal with Walk, Fly {\n   Bat(super.nombre);\n-\n-  // 8. Sobrescritura de toString()\n   @override\n-  String toString() => \"Soy un Murciélago llamado $nombre que puede ${runtimeType.toString() is Fly ? 'volar' : ''} y ${runtimeType.toString() is Walk ? 'caminar' : ''}\";\n+  String toString() => \"Soy el Murciélago $nombre que vuela y camina.\"; // 8.\n }\n \n-// 4. Dolphin: hereda de Mammal e implementa Swim.\n+// 4. Dolphin: Mammal + Swim\n class Dolphin extends Mammal with Swim {\n   Dolphin(super.nombre);\n-  \n-  // Redefine mover para ser más específico\n   @override\n-  void mover() => print(\"$nombre (Delfín) nada en el mar.\");\n+  void mover() => print(\"$nombre (Delfín) nada a gran velocidad.\");\n+  @override\n+  String toString() => \"Soy el Delfín $nombre y soy un mamífero acuático.\"; // 8.\n+}\n \n-  // 8. Sobrescritura de toString()\n+// 5. Duck: Bird + Walk, Swim, Fly\n+class Duck extends Bird with Walk, Swim, Fly {\n+  Duck(super.nombre);\n   @override\n-  String toString() => \"Soy un Delfín llamado $nombre que nada\";\n+  void mover() => print(\"$nombre (Pato) es versátil: camina, nada y vuela.\");\n+  @override\n+  String toString() => \"Soy el Pato $nombre, un campeón de los tres elementos.\"; // 8.\n }\n \n-// Clase Shark (Pez simple)\n+// Shark: Pez simple (ejemplo para 7 y 10)\n class Shark extends Fish {\n   Shark(super.nombre);\n-\n-  // 8. Sobrescritura de toString()\n   @override\n-  String toString() => \"Soy un Tiburón llamado $nombre\";\n+  String toString() => \"Soy el Tiburón $nombre, depredador marino.\"; // 8.\n }\n \n-// FlyingFish: Pez que también puede volar (ejercicio 10)\n+// FlyingFish: Fish + Fly (ejemplo para 10)\n class FlyingFish extends Fish with Fly {\n   FlyingFish(super.nombre);\n }\n \n \n-// 5. Duck: hereda de Bird e implementa Walk, Swim y Fly.\n-class Duck extends Bird with Walk, Swim, Fly {\n-  Duck(super.nombre);\n-  \n-  // Redefine mover para ser más específico\n-  @override\n-  void mover() => print(\"$nombre (Pato) se mueve en tierra, aire y agua.\");\n-\n-  // 8. Sobrescritura de toString()\n-  @override\n-  String toString() => \"Soy un Pato llamado $nombre con múltiples habilidades (volar, nadar, caminar)\";\n-}\n-\n // -----------------------------------------------------------\n // Función principal (main)\n // -----------------------------------------------------------\n void main() {\n-  print(\"--- 1. 2. 3. 4. 5. Jerarquía de Clases y Mixins ---\");\n-  // 3. Crea un Bird y un Fish e imprime su movimiento.\n-  var cigueña = Bird(\"Cigüeña\");\n-  var salmon = Fish(\"Salmón\");\n-  cigueña.mover(); // Lógica: Usa el método mover() de Bird\n-  salmon.mover();  // Lógica: Usa el método mover() de Fish\n+  print(\"--- PRUEBAS PRINCIPALES ---\");\n+  var patoDonald = Duck(\"Donald\");\n+  var murcielagoVlad = Bat(\"Vlad\");\n+  var gatoPelusa = Cat(\"Pelusa\");\n \n-  // 5. Instancia un Duck y llama a sus tres comportamientos.\n-  var patoDonald = Duck(\"Donald\");\n+  // 5. Comportamientos múltiples (Duck)\n   print(\"\\nComportamientos de ${patoDonald.nombre}:\");\n-  patoDonald.caminar(); // Lógica: Método del mixin Walk\n-  patoDonald.nadar();   // Lógica: Método del mixin Swim\n-  patoDonald.volar();   // Lógica: Método del mixin Fly\n+  patoDonald.caminar();\n+  patoDonald.nadar();\n+  patoDonald.volar();\n \n-  print(\"\\n--- 6. Encapsulación y Getters/Setters ---\");\n-  // 6. Prueba el setter de Animal\n-  patoDonald.edad = 5; // Lógica: Asigna 5 a _edad a través del setter\n+  // 6. Encapsulación y Getters/Setters\n+  patoDonald.edad = 5;\n   print(\"${patoDonald.nombre} tiene ${patoDonald.edad} años.\");\n-  patoDonald.edad = -2; // Lógica: El setter impide la asignación y muestra el error.\n-  print(\"Tras intento inválido, ${patoDonald.nombre} sigue teniendo ${patoDonald.edad} años.\");\n+  patoDonald.edad = -2; // Prueba de validación\n \n   print(\"\\n--- 7. Polimorfismo ---\");\n-  // 7. Lista de animales heterogénea (Polimorfismo)\n+  // 7. Lista de Animales\n   List<Animal> animales = [\n-    Cat(\"Pelusa\"),\n-    patoDonald, // El pato ya instanciado\n+    gatoPelusa,\n+    patoDonald,\n     Shark(\"Tiburón Blanco\"),\n-    Bat(\"Drácula\"),\n+    murcielagoVlad,\n     Dolphin(\"Flipper\"),\n   ];\n \n-  // Recorre la lista y llama a mover(). Cada objeto usa su implementación.\n+  // Recorre la lista y llama a mover() (Polimorfismo)\n   for (var a in animales) {\n-    a.mover(); // Lógica: El método llamado se determina en tiempo de ejecución.\n+    a.mover();\n   }\n-\n-  print(\"\\n--- 8. Sobrescritura de toString() ---\");\n-  // 8. Imprime la descripción de algunos objetos\n-  print(animales[0]); // Lógica: Usa el toString() reescrito de Cat\n-  print(animales[3]); // Lógica: Usa el toString() reescrito de Bat\n-\n-  print(\"\\n--- 10. Ejercicio Integrador – Zoológico ---\");\n-  // 10. Lista integradora con FlyingFish\n+  \n+  print(\"\\n--- 10. Ejercicio Integrador – Zoológico (Capacidades) ---\");\n   List<Animal> zoologico = [\n     Cat(\"Garfield\"),\n     Dolphin(\"Luna\"),\n     Duck(\"Cuack\"),\n@@ -195,12 +161,12 @@\n   ];\n \n   for (var animal in zoologico) {\n     print(\"\\n${animal.nombre} (${animal.runtimeType}):\");\n-    // Lógica: Usa el operador 'is' para verificar si el objeto tiene la capacidad\n-    // proporcionada por el mixin (comprobación de tipo en tiempo de ejecución).\n+    // Lógica: Se usa 'is' para comprobar las capacidades de los mixins.\n     if (animal is Walk) animal.caminar();\n     if (animal is Swim) animal.nadar();\n     if (animal is Fly) animal.volar();\n-    animal.mover(); // Muestra el movimiento por defecto (polimorfismo)\n+    \n+    animal.mover(); // Llama a la implementación polimórfica\n   }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760606993064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,20 +89,18 @@\n   Dolphin(super.nombre);\n   @override\n   void mover() => print(\"$nombre (Delfín) nada a gran velocidad.\");\n   @override\n-  String toString() =>\n-      \"Soy el Delfín $nombre y soy un mamífero acuático.\"; // 8.\n+  String toString() => \"Soy el Delfín $nombre y soy un mamífero acuático.\"; // 8.\n }\n \n // 5. Duck: Bird + Walk, Swim, Fly\n class Duck extends Bird with Walk, Swim, Fly {\n   Duck(super.nombre);\n   @override\n   void mover() => print(\"$nombre (Pato) es versátil: camina, nada y vuela.\");\n   @override\n-  String toString() =>\n-      \"Soy el Pato $nombre, un campeón de los tres elementos.\"; // 8.\n+  String toString() => \"Soy el Pato $nombre, un campeón de los tres elementos.\"; // 8.\n }\n \n // Shark: Pez simple (ejemplo para 7 y 10)\n class Shark extends Fish {\n@@ -115,8 +113,9 @@\n class FlyingFish extends Fish with Fly {\n   FlyingFish(super.nombre);\n }\n \n+\n // -----------------------------------------------------------\n // Función principal (main)\n // -----------------------------------------------------------\n void main() {\n@@ -149,9 +148,9 @@\n   // Recorre la lista y llama a mover() (Polimorfismo)\n   for (var a in animales) {\n     a.mover();\n   }\n-\n+  \n   print(\"\\n--- 10. Ejercicio Integrador – Zoológico (Capacidades) ---\");\n   List<Animal> zoologico = [\n     Cat(\"Garfield\"),\n     Dolphin(\"Luna\"),\n@@ -166,8 +165,8 @@\n     // Lógica: Se usa 'is' para comprobar las capacidades de los mixins.\n     if (animal is Walk) animal.caminar();\n     if (animal is Swim) animal.nadar();\n     if (animal is Fly) animal.volar();\n-\n+    \n     animal.mover(); // Llama a la implementación polimórfica\n   }\n-}\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1760630422131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,173 +1,345 @@\n-// -----------------------------------------------------------\n-// 9. Clase abstracta Animal y 6. Encapsulación\n-// -----------------------------------------------------------\n-abstract class Animal {\n-  String nombre;\n-  int _edad = 0; // 6. Campo privado\n+// =============================================\n+// BLOQUE 1: Jerarquía Animal (SOLO ESPECIE)\n+// =============================================\n \n-  Animal(this.nombre); // 1. Constructor\n+// 1. Clase base Animal\n+class Animal {\n+  String especie = '';\n+  Animal(this.especie);\n \n-  // 9. Método abstracto: sin implementación\n-  void mover();\n+  void mover() {\n+    print(\"El animal se mueve\");\n+  }\n+}\n+// Lógica: Clase base minimalista usando solo especie para identificar animales\n \n-  // 6. Getter\n-  int get edad => _edad;\n+// 2. Subclases Mammal, Bird y Fish\n+// Lógica: Herencia simple con comportamiento específico para mamíferos\n+  class Mammal extends Animal {\n+    Mammal(super.especie);\n \n-  // 6. Setter con validación\n-  set edad(int e) {\n-    if (e >= 0) {\n-      _edad = e;\n-    } else {\n-      print(\"Error: La edad no puede ser negativa.\");\n-    }\n+    @override\n+    void mover() => print(\"$especie camina sobre la tierra\");\n   }\n \n-  // 8. Sobrescritura de toString()\n+class Bird extends Animal {\n+  Bird(super.especie);\n+\n   @override\n-  String toString() => \"Un $nombre de tipo ${runtimeType.toString()}\";\n+  void mover() => print(\"$especie vuela por el aire\");\n }\n+// Lógica: Redefinición de método para comportamiento aéreo\n \n-// -----------------------------------------------------------\n-// 4. Mixins para Comportamientos\n-// -----------------------------------------------------------\n+class Fish extends Animal {\n+  Fish(super.especie);\n+\n+  @override\n+  void mover() => print(\"$especie nada en el agua\");\n+}\n+// Lógica: Especialización para movimiento acuático\n+\n+// 3. Constructores con super() - Ya implementado\n+// Lógica: Paso de parámetro al constructor padre usando super\n+\n+// 4. Mixins para comportamientos\n mixin Walk {\n-  void caminar() => print(\"Caminando sobre la tierra.\");\n+  void caminar() => print(\"${(this as Animal).especie} está caminando\");\n }\n+// Lógica: Mixin reutilizable para capacidad de caminar\n \n mixin Swim {\n-  void nadar() => print(\"Nadando en el agua.\");\n+  void nadar() => print(\"${(this as Animal).especie} está nadando\");\n }\n+// Lógica: Mixin para comportamiento de natación\n \n mixin Fly {\n-  void volar() => print(\"Volando por el aire.\");\n+  void volar() => print(\"${(this as Animal).especie} está volando\");\n }\n+// Lógica: Mixin modular para capacidad de vuelo\n \n-// -----------------------------------------------------------\n-// 2. 3. Subclases Mammal, Bird, Fish\n-// -----------------------------------------------------------\n-class Mammal extends Animal {\n-  Mammal(super.nombre); // 3. super()\n+// Clases que combinan herencia y mixins\n+class Bat extends Mammal with Walk, Fly {\n+  Bat() : super(\"Murciélago\");\n+}\n+// Lógica: Combinación de herencia mamífero con capacidades de caminar y volar\n \n-  @override // 2. Redefinición obligatoria (por clase abstracta)\n-  void mover() => print(\"$nombre (Mamífero) se mueve típicamente por tierra.\");\n+class Dolphin extends Mammal with Swim {\n+  Dolphin() : super(\"Delfín\");\n }\n+// Lógica: Mamífero especializado en ambiente acuático\n \n-class Bird extends Animal {\n-  Bird(super.nombre);\n+// 5. Comportamientos múltiples\n+class Duck extends Bird with Walk, Swim, Fly {\n+  Duck() : super(\"Pato\");\n+}\n+// Lógica: Ave con capacidades terrestres, aéreas y acuáticas completas\n \n-  @override // 2. Redefinición obligatoria\n-  void mover() => print(\"$nombre (Ave) se mueve típicamente volando.\");\n+// 6. Encapsulación - No necesaria en esta versión simplificada\n+// Lógica: Versión minimalista sin campos privados\n+\n+// 7. Polimorfismo\n+class Cat extends Mammal with Walk {\n+  Cat() : super(\"Gato\");\n }\n+// Lógica: Clase concreta para demostración de polimorfismo\n \n-class Fish extends Animal {\n-  Fish(super.nombre);\n+class Shark extends Fish with Swim {\n+  Shark() : super(\"Tiburón\");\n+}\n+// Lógica: Especialización de pez con comportamiento depredador\n \n-  @override // 2. Redefinición obligatoria\n-  void mover() => print(\"$nombre (Pez) se mueve típicamente nadando.\");\n+// 8. Sobrescritura de toString()\n+class FlyingFish extends Fish with Swim, Fly {\n+  FlyingFish() : super(\"Pez Volador\");\n+\n+  @override\n }\n+// Lógica: Redefinición de toString para descripción personalizada\n \n-// -----------------------------------------------------------\n-// 4. 5. 10. Clases Concretas con Mixins\n-// -----------------------------------------------------------\n+// 9. Clase abstracta Animal\n+abstract class AnimalAbstracto {\n+  String especie;\n+  AnimalAbstracto(this.especie);\n \n-// Cat: Mamífero simple\n-class Cat extends Mammal {\n-  Cat(super.nombre);\n+  void mover(); // Método abstracto sin implementación\n+  String toString() => \"Soy un $especie que puede nadar y volar\";\n+}\n+// Lógica: Definición de interfaz abstracta para obligar implementación\n+// 10. Ejercicio integrador - Zoológico\n+\n+void ejercicioIntegradorZoologico() {\n+  print('\\n--- ZOOLÓGICO VIRTUAL ---');\n+\n+  List<Animal> animales = [\n+    Cat(),\n+    Dolphin(),\n+    Duck(),\n+    Bat(),\n+    Shark(),\n+    FlyingFish()\n+  ];\n+\n+  for (var animal in animales) {\n+    print('\\n🔹 ${animal.especie}:');\n+    animal.mover();\n+\n+    if (animal is Walk) animal.caminar();\n+    if (animal is Swim) animal.nadar();\n+    if (animal is Fly) animal.volar();\n+\n+    if (animal is FlyingFish) print(animal.toString());\n+  }\n+}\n+// Lógica: Demostración completa con lista polimórfica y verificación de capacidades\n+\n+// =============================================\n+// BLOQUE 2: Ejemplos alternativos (SOLO ESPECIE)\n+// =============================================\n+\n+// 1. Clase base con constructor y atributos\n+class AnimalAlternativo {\n+  String especie;\n+\n+  AnimalAlternativo(this.especie);\n+\n+  void descripcion() {\n+    print('Es un $especie');\n+  }\n+}\n+// Lógica: Clase simple enfocada solo en la especie\n+\n+// 2. Subclases con comportamiento específico\n+class Perro extends AnimalAlternativo {\n+  Perro() : super('Perro');\n+\n   @override\n-  String toString() => \"Soy un Gato llamado $nombre\"; // 8.\n+  void descripcion() {\n+    print('Es un perro');\n+  }\n }\n+// Lógica: Herencia con sobrescritura de descripción\n \n-// 4. Bat: Mammal + Walk, Fly\n-class Bat extends Mammal with Walk, Fly {\n-  Bat(super.nombre);\n+// 3. Uso de getters y setters\n+class Ave {\n+  double _alturaVuelo = 0;\n+\n+  double get alturaVuelo => _alturaVuelo;\n+  set alturaVuelo(double valor) {\n+    if (valor >= 0) _alturaVuelo = valor;\n+  }\n+}\n+// Lógica: Encapsulación con validación en setter\n+\n+// 4. Herencia + método extra\n+class Pez extends AnimalAlternativo {\n+  Pez() : super('Pez');\n+\n+  void nadar() => print(\"El pez está nadando\");\n+}\n+// Lógica: Herencia con método adicional específico\n+\n+// 5. Constructores nombrados\n+class Gato {\n+  String especie;\n+  int edad;\n+\n+  Gato()\n+      : especie = 'Gato',\n+        edad = 1;\n+\n+  Gato.bebe()\n+      : especie = 'Gato',\n+        edad = 0;\n+}\n+// Lógica: Constructores múltiples con valores por defecto\n+\n+// 6. Clase abstracta y herencia\n+abstract class Vehiculo {\n+  void mover();\n+}\n+\n+class Coche extends Vehiculo {\n   @override\n-  String toString() => \"Soy el Murciélago $nombre que vuela y camina.\"; // 8.\n+  void mover() => print(\"El coche se desplaza por la carretera\");\n }\n \n-// 4. Dolphin: Mammal + Swim\n-class Dolphin extends Mammal with Swim {\n-  Dolphin(super.nombre);\n+class Avion extends Vehiculo {\n   @override\n-  void mover() => print(\"$nombre (Delfín) nada a gran velocidad.\");\n+  void mover() => print(\"El avión vuela por el cielo\");\n+}\n+// Lógica: Implementación de interfaz abstracta\n+\n+// 7. Polimorfismo\n+void demostrarPolimorfismo() {\n+  List<Vehiculo> vehiculos = [Coche(), Avion()];\n+\n+  for (var vehiculo in vehiculos) {\n+    vehiculo.mover();\n+  }\n+}\n+// Lógica: Tratamiento polimórfico de objetos diferentes\n+\n+// 8. Composición\n+class Corazon {\n+  void latir() => print(\"❤️ Latido...\");\n+}\n+\n+class Persona {\n+  Corazon corazon = Corazon();\n+\n+  void vivir() => corazon.latir();\n+}\n+// Lógica: Relación de composición entre objetos\n+\n+// 9. Mixins alternativos\n+mixin Caminar {\n+  void caminar() => print(\"Caminando...\");\n+}\n+\n+mixin Volar {\n+  void volar() => print(\"Volando...\");\n+}\n+\n+mixin Nadar {\n+  void nadar() => print(\"Nadando...\");\n+}\n+\n+class Pinguino with Caminar, Nadar {}\n+\n+class Murcielago with Caminar, Volar {}\n+\n+class Pato with Caminar, Volar, Nadar {}\n+// Lógica: Combinaciones específicas de mixins\n+\n+// 10. Ejercicio integrador - Zoológico alternativo\n+abstract class AnimalZoologico {\n+  String especie;\n+  AnimalZoologico(this.especie);\n+  void mover();\n+}\n+\n+class Mamifero extends AnimalZoologico {\n+  Mamifero(String especie) : super(especie);\n   @override\n-  String toString() =>\n-      \"Soy el Delfín $nombre y soy un mamífero acuático.\"; // 8.\n+  void mover() => print(\"El $especie se mueve como mamífero\");\n }\n \n-// 5. Duck: Bird + Walk, Swim, Fly\n-class Duck extends Bird with Walk, Swim, Fly {\n-  Duck(super.nombre);\n+class GatoZoologico extends Mamifero with Caminar {\n+  GatoZoologico() : super('Gato');\n+}\n+\n+class DelfinZoologico extends Mamifero with Nadar {\n+  DelfinZoologico() : super('Delfín');\n+}\n+\n+class PatoZoologico extends AnimalZoologico with Caminar, Volar, Nadar {\n+  PatoZoologico() : super('Pato');\n   @override\n-  void mover() => print(\"$nombre (Pato) es versátil: camina, nada y vuela.\");\n-  @override\n-  String toString() =>\n-      \"Soy el Pato $nombre, un campeón de los tres elementos.\"; // 8.\n+  void mover() => print(\"El pato se mueve de múltiples formas\");\n }\n \n-// Shark: Pez simple (ejemplo para 7 y 10)\n-class Shark extends Fish {\n-  Shark(super.nombre);\n+class TiburonZoologico extends AnimalZoologico with Nadar {\n+  TiburonZoologico() : super('Tiburón');\n   @override\n-  String toString() => \"Soy el Tiburón $nombre, depredador marino.\"; // 8.\n+  void mover() => print(\"El tiburón se mueve como pez depredador\");\n }\n \n-// FlyingFish: Fish + Fly (ejemplo para 10)\n-class FlyingFish extends Fish with Fly {\n-  FlyingFish(super.nombre);\n+void ejercicioIntegradorCompleto() {\n+  print('\\n--- ZOOLÓGICO COMPLETO ---');\n+\n+  List<AnimalZoologico> animales = [\n+    GatoZoologico(),\n+    DelfinZoologico(),\n+    PatoZoologico(),\n+    TiburonZoologico()\n+  ];\n+\n+  for (var animal in animales) {\n+    print('\\n🔹 ${animal.especie}:');\n+    animal.mover();\n+\n+    if (animal is Caminar) {\n+      animal.caminar();\n+      print(\"✅ Puede caminar\");\n+    }\n+    if (animal is Volar) {\n+      animal.volar();\n+      print(\"✅ Puede volar\");\n+    }\n+    if (animal is Nadar) {\n+      animal.nadar();\n+      print(\"✅ Puede nadar\");\n+    }\n+  }\n }\n \n-// -----------------------------------------------------------\n-// Función principal (main)\n-// -----------------------------------------------------------\n+// =============================================\n+// FUNCIÓN PRINCIPAL\n+// =============================================\n+\n void main() {\n-  print(\"--- PRUEBAS PRINCIPALES ---\");\n-  var patoDonald = Duck(\"Donald\");\n-  var murcielagoVlad = Bat(\"Vlad\");\n-  var gatoPelusa = Cat(\"Pelusa\");\n+  print('=== EJERCICIOS 15-OCT-2025 - POO SIMPLIFICADO ===');\n \n-  // 5. Comportamientos múltiples (Duck)\n-  print(\"\\nComportamientos de ${patoDonald.nombre}:\");\n-  patoDonald.caminar();\n-  patoDonald.nadar();\n-  patoDonald.volar();\n \n-  // 6. Encapsulación y Getters/Setters\n-  patoDonald.edad = 5;\n-  print(\"${patoDonald.nombre} tiene ${patoDonald.edad} años.\");\n-  patoDonald.edad = -2; // Prueba de validación\n \n-  print(\"\\n--- 7. Polimorfismo ---\");\n-  // 7. Lista de Animales\n-  List<Animal> animales = [\n-    gatoPelusa,\n-    patoDonald,\n-    Shark(\"Tiburón Blanco\"),\n-    murcielagoVlad,\n-    Dolphin(\"Flipper\"),\n-  ];\n \n-  // Recorre la lista y llama a mover() (Polimorfismo)\n-  for (var a in animales) {\n-    a.mover();\n-  }\n+  // Bloque 1: Jerarquía Animal\n+  print('\\n--- BLOQUE 1: JERARQUÍA ANIMAL ---');\n \n-  print(\"\\n--- 10. Ejercicio Integrador – Zoológico (Capacidades) ---\");\n-  List<Animal> zoologico = [\n-    Cat(\"Garfield\"),\n-    Dolphin(\"Luna\"),\n-    Duck(\"Cuack\"),\n-    Bat(\"Chiro\"),\n-    Shark(\"Bruce\"),\n-    FlyingFish(\"Icarus\"),\n-  ];\n+  Bird pajaro = Bird(\"Gorrión\");\n+  Fish pez = Fish(\"Salmón\");\n+  pajaro.mover();\n+  pez.mover();\n \n-  for (var animal in zoologico) {\n-    print(\"\\n${animal.nombre} (${animal.runtimeType}):\");\n-    // Lógica: Se usa 'is' para comprobar las capacidades de los mixins.\n-    if (animal is Walk) animal.caminar();\n-    if (animal is Swim) animal.nadar();\n-    if (animal is Fly) animal.volar();\n+  Duck pato = Duck();\n+  print('\\n--- Pato con múltiples comportamientos ---');\n+  pato.mover();\n+  pato.caminar();\n+  pato.nadar();\n+  pato.volar();\n \n-    animal.mover(); // Llama a la implementación polimórfica\n-  }\n+\n+\n+\n+  \n }\n"
                }
            ],
            "date": 1760603869496,
            "name": "Commit-0",
            "content": "// -----------------------------------------------------------\n// 1. Clase base Animal (convertida a abstracta en el ejercicio 9)\n// -----------------------------------------------------------\nabstract class Animal {\n  // Campo para el nombre\n  String nombre;\n  // 6. Campo privado para la edad\n  int _edad = 0;\n\n  // 1. Constructor\n  Animal(this.nombre);\n\n  // 9. Método abstracto: sin implementación en la clase base.\n  void mover();\n\n  // 6. Getter para _edad\n  int get edad => _edad;\n\n  // 6. Setter para _edad (impide valores negativos)\n  set edad(int e) {\n    if (e >= 0) {\n      _edad = e;\n    } else {\n      print(\"Error: La edad no puede ser negativa.\");\n    }\n  }\n\n  // 8. Sobrescritura básica de toString()\n  @override\n  String toString() => \"Un $nombre de tipo ${runtimeType.toString()}\";\n}\n\n// -----------------------------------------------------------\n// 2. Subclases Mammal, Bird, Fish\n// -----------------------------------------------------------\nclass Mammal extends Animal {\n  // 3. Constructor que pasa 'nombre' al constructor de la clase base.\n  Mammal(super.nombre);\n\n  // 2. Redefinición obligatoria de mover()\n  @override\n  void mover() => print(\"$nombre (Mamífero) camina sobre la tierra\");\n}\n\nclass Bird extends Animal {\n  Bird(super.nombre);\n\n  // 2. Redefinición obligatoria de mover()\n  @override\n  void mover() => print(\"$nombre (Ave) vuela por el aire\");\n}\n\nclass Fish extends Animal {\n  Fish(super.nombre);\n\n  // 2. Redefinición obligatoria de mover()\n  @override\n  void mover() => print(\"$nombre (Pez) nada en el agua\");\n}\n\n// -----------------------------------------------------------\n// 4. Mixins\n// -----------------------------------------------------------\n// Los mixins proporcionan una forma de reutilizar el código de la clase\n// en múltiples jerarquías de clases.\nmixin Walk {\n  void caminar() => print(\"Caminando...\");\n}\n\nmixin Swim {\n  void nadar() => print(\"Nadando...\");\n}\n\nmixin Fly {\n  void volar() => print(\"Volando...\");\n}\n\n// -----------------------------------------------------------\n// Clases concretas (ejercicios 4, 5, 8, 10)\n// -----------------------------------------------------------\n\n// Clase Cat (Mamífero simple)\nclass Cat extends Mammal {\n  Cat(super.nombre);\n\n  // 8. Sobrescritura de toString()\n  @override\n  String toString() => \"Soy un Gato llamado $nombre\";\n}\n\n// 4. Bat: hereda de Mammal e implementa Walk y Fly.\nclass Bat extends Mammal with Walk, Fly {\n  Bat(super.nombre);\n\n  // 8. Sobrescritura de toString()\n  @override\n  String toString() => \"Soy un Murciélago llamado $nombre que puede ${runtimeType.toString() is Fly ? 'volar' : ''} y ${runtimeType.toString() is Walk ? 'caminar' : ''}\";\n}\n\n// 4. Dolphin: hereda de Mammal e implementa Swim.\nclass Dolphin extends Mammal with Swim {\n  Dolphin(super.nombre);\n  \n  // Redefine mover para ser más específico\n  @override\n  void mover() => print(\"$nombre (Delfín) nada en el mar.\");\n\n  // 8. Sobrescritura de toString()\n  @override\n  String toString() => \"Soy un Delfín llamado $nombre que nada\";\n}\n\n// Clase Shark (Pez simple)\nclass Shark extends Fish {\n  Shark(super.nombre);\n\n  // 8. Sobrescritura de toString()\n  @override\n  String toString() => \"Soy un Tiburón llamado $nombre\";\n}\n\n// FlyingFish: Pez que también puede volar (ejercicio 10)\nclass FlyingFish extends Fish with Fly {\n  FlyingFish(super.nombre);\n}\n\n\n// 5. Duck: hereda de Bird e implementa Walk, Swim y Fly.\nclass Duck extends Bird with Walk, Swim, Fly {\n  Duck(super.nombre);\n  \n  // Redefine mover para ser más específico\n  @override\n  void mover() => print(\"$nombre (Pato) se mueve en tierra, aire y agua.\");\n\n  // 8. Sobrescritura de toString()\n  @override\n  String toString() => \"Soy un Pato llamado $nombre con múltiples habilidades (volar, nadar, caminar)\";\n}\n\n// -----------------------------------------------------------\n// Función principal (main)\n// -----------------------------------------------------------\nvoid main() {\n  print(\"--- 1. 2. 3. 4. 5. Jerarquía de Clases y Mixins ---\");\n  // 3. Crea un Bird y un Fish e imprime su movimiento.\n  var cigueña = Bird(\"Cigüeña\");\n  var salmon = Fish(\"Salmón\");\n  cigueña.mover(); // Lógica: Usa el método mover() de Bird\n  salmon.mover();  // Lógica: Usa el método mover() de Fish\n\n  // 5. Instancia un Duck y llama a sus tres comportamientos.\n  var patoDonald = Duck(\"Donald\");\n  print(\"\\nComportamientos de ${patoDonald.nombre}:\");\n  patoDonald.caminar(); // Lógica: Método del mixin Walk\n  patoDonald.nadar();   // Lógica: Método del mixin Swim\n  patoDonald.volar();   // Lógica: Método del mixin Fly\n\n  print(\"\\n--- 6. Encapsulación y Getters/Setters ---\");\n  // 6. Prueba el setter de Animal\n  patoDonald.edad = 5; // Lógica: Asigna 5 a _edad a través del setter\n  print(\"${patoDonald.nombre} tiene ${patoDonald.edad} años.\");\n  patoDonald.edad = -2; // Lógica: El setter impide la asignación y muestra el error.\n  print(\"Tras intento inválido, ${patoDonald.nombre} sigue teniendo ${patoDonald.edad} años.\");\n\n  print(\"\\n--- 7. Polimorfismo ---\");\n  // 7. Lista de animales heterogénea (Polimorfismo)\n  List<Animal> animales = [\n    Cat(\"Pelusa\"),\n    patoDonald, // El pato ya instanciado\n    Shark(\"Tiburón Blanco\"),\n    Bat(\"Drácula\"),\n    Dolphin(\"Flipper\"),\n  ];\n\n  // Recorre la lista y llama a mover(). Cada objeto usa su implementación.\n  for (var a in animales) {\n    a.mover(); // Lógica: El método llamado se determina en tiempo de ejecución.\n  }\n\n  print(\"\\n--- 8. Sobrescritura de toString() ---\");\n  // 8. Imprime la descripción de algunos objetos\n  print(animales[0]); // Lógica: Usa el toString() reescrito de Cat\n  print(animales[3]); // Lógica: Usa el toString() reescrito de Bat\n\n  print(\"\\n--- 10. Ejercicio Integrador – Zoológico ---\");\n  // 10. Lista integradora con FlyingFish\n  List<Animal> zoologico = [\n    Cat(\"Garfield\"),\n    Dolphin(\"Luna\"),\n    Duck(\"Cuack\"),\n    Bat(\"Chiro\"),\n    Shark(\"Bruce\"),\n    FlyingFish(\"Icarus\"),\n  ];\n\n  for (var animal in zoologico) {\n    print(\"\\n${animal.nombre} (${animal.runtimeType}):\");\n    // Lógica: Usa el operador 'is' para verificar si el objeto tiene la capacidad\n    // proporcionada por el mixin (comprobación de tipo en tiempo de ejecución).\n    if (animal is Walk) animal.caminar();\n    if (animal is Swim) animal.nadar();\n    if (animal is Fly) animal.volar();\n    animal.mover(); // Muestra el movimiento por defecto (polimorfismo)\n  }\n}"
        }
    ]
}